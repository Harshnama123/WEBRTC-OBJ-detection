<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Object Detection Demo - Laptop View</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #1a1a1a;
      color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .container { max-width: 1200px; width: 100%; }
    .header { text-align: center; margin-bottom: 30px; }
    .qr-section {
      text-align: center;
      margin-bottom: 30px;
      padding: 20px;
      border: 2px dashed #4CAF50;
      border-radius: 10px;
    }
    .phone-url {
      font-size: 18px;
      color: #4CAF50;
      margin: 10px 0;
    }
    .video-container {
      position: relative;
      margin: 20px auto;
      width: 100%;
      max-width: 800px;
      background: #000;
      border-radius: 10px;
      overflow: hidden;
    }
    
    .video-display-area {
      position: relative;
      width: 100%;
      height: 0;
      padding-bottom: 56.25%; /* 16:9 aspect ratio */
      background: #000;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    
    #remoteVideo {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
      background: #000;
    }
    
    #playOverlay button:hover {
      background: #45a049 !important;
      transform: scale(1.05);
      transition: all 0.2s ease;
    }
    #remoteVideo {
      width: 100%;
      max-width: 640px;
      height: auto;
      min-width: 320px;
      min-height: 240px;
      background: #1a1a1a;
      border: 2px solid #00ff00;
      display: block;
      object-fit: contain;
      margin: 0 auto;
    }
    #detectionCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    .detection-stats {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.8);
      padding: 15px;
      border-radius: 8px;
      color: white;
      font-family: monospace;
      font-size: 14px;
      border: 1px solid rgba(255,255,255,0.1);
    }
    .status { text-align: center; padding: 10px; margin: 10px 0; border-radius: 5px; background: #333; }
    .connected { background: #4CAF50; }
    .disconnected { background: #f44336; }
    .waiting { background: #ff9800; }
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>ðŸŽ¯ Real-time Object Detection</h1>
      <p>Scan QR code with your phone to start streaming</p>
    </div>
    
    <div class="qr-section">
      <h3>ðŸ“± Connect Your Phone</h3>
      <div style="background: #333; padding: 20px; border-radius: 10px; margin: 20px 0;">
        <p style="font-size: 18px; margin-bottom: 10px;">On your phone, visit:</p>
        <div class="phone-url" style="font-size: 24px; font-weight: bold;">
          <span id="phoneUrl">Loading...</span>
        </div>
        <div style="margin-top: 15px;">
          <button onclick="copyUrl()" style="padding: 10px 20px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">
            ðŸ“‹ Copy URL
          </button>
        </div>
      </div>
      <p><small>Make sure your phone and laptop are on the same WiFi network</small></p>
    </div>
    
    <div class="status waiting" id="status">
      Waiting for phone connection...
    </div>
    
    <div class="video-container">
        <h3>Phone Camera Feed</h3>
        <div class="video-display-area">
            <video id="remoteVideo" 
                   playsinline 
                   autoplay
                   muted
                   style="width: 100%; max-width: 640px; height: auto; display: none; background: #000;">
            </video>
            <canvas id="detectionCanvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></canvas>
            <div id="stream-status" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; background: rgba(0,0,0,0.7); padding: 20px; border-radius: 10px;">
                <div style="margin-bottom: 20px; color: white;">Connecting to camera stream...</div>
                <div id="stream-error" style="color: #ff4444; display: none;"></div>
            </div>
            <div id="video-stats" style="position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.7); color: white; padding: 10px; border-radius: 5px; font-family: monospace; display: none;">
            </div>
        </div>
    </div>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script src="video-manager.js"></script>
  <script>
    const socket = io();
    let ctx;
    let canvas;
    let statsEl;
    let videoManager;
    const statusEl = document.getElementById('status');
    const remoteVideo = document.getElementById('remoteVideo');
    const phoneUrlEl = document.getElementById('phoneUrl');
    
    // Initialize video manager
    const streamStatus = document.getElementById('stream-status');
    const videoStats = document.getElementById('video-stats');
    videoManager = new VideoManager(remoteVideo, streamStatus, videoStats);

    // Initialize canvas and stats elements
    function initializeCanvas() {
      canvas = document.getElementById('detectionCanvas');
      if (canvas) {
        ctx = canvas.getContext('2d');
      }
      statsEl = document.getElementById('stats');
    }

    // Wait for DOM to load before initializing canvas
    document.addEventListener('DOMContentLoaded', initializeCanvas);

    async function setupVideoStream(event) {
        try {
            console.log('ðŸ“¹ Track received:', event.track.kind);
            
            const remoteVideo = document.getElementById('remoteVideo');
            const playOverlay = document.getElementById('playOverlay');
            const streamStatus = document.getElementById('streamStatus');
            
            // Get the stream from the event
            const [remoteStream] = event.streams;
            if (!remoteStream) {
                console.error('No stream in track event');
                return;
            }
            
            console.log('Got remote stream:', remoteStream.id);
            remoteVideo.srcObject = remoteStream;
            
            // Wait for the track to become active
            await new Promise((resolve) => {
                const checkTrack = () => {
                    if (!event.track.muted) {
                        resolve();
                    } else {
                        setTimeout(checkTrack, 100);
                    }
                };
                checkTrack();
            });
            
            if (event.streams && event.streams[0]) {
                const stream = event.streams[0];
                const videoTrack = event.track;
                
                console.log('Initial track state:', {
                    enabled: videoTrack.enabled,
                    state: videoTrack.readyState,
                    settings: videoTrack.getSettings()
                });
                
                // Set up track event handlers
                videoTrack.onmute = () => {
                    console.log('ðŸ”‡ Track muted');
                    streamStatus.textContent = 'muted';
                    streamStatus.style.color = '#ff9800';
                };
                
                videoTrack.onunmute = () => {
                    console.log('ðŸ”Š Track unmuted');
                    streamStatus.textContent = 'active';
                    streamStatus.style.color = '#4CAF50';
                };
                
                videoTrack.onended = () => {
                    console.log('â¹ï¸ Track ended');
                    streamStatus.textContent = 'ended';
                    streamStatus.style.color = '#ff4444';
                };
                
                // Wait for track to be ready
                await new Promise((resolve, reject) => {
                    if (videoTrack.readyState === 'live') {
                        resolve();
                    } else {
                        let timeout;
                        const cleanup = () => {
                            videoTrack.onmute = null;
                            videoTrack.onunmute = null;
                            clearTimeout(timeout);
                        };
                        
                        videoTrack.onmute = () => { cleanup(); resolve(); };
                        videoTrack.onunmute = () => { cleanup(); resolve(); };
                        
                        // Timeout after 5s
                        timeout = setTimeout(() => {
                            cleanup();
                            reject(new Error('Track ready timeout'));
                        }, 5000);
                    }
                }).catch(err => {
                    console.warn('Warning: Track ready timeout, continuing anyway');
                });
                
                // Get and log track settings
                const settings = videoTrack.getSettings();
                console.log('ðŸ“¹ Video track settings:', settings);
                
                // Instead of trying to constrain the track, we'll set the video element's dimensions
                remoteVideo.playsInline = true;
                remoteVideo.autoplay = true;
                remoteVideo.muted = true;
                
                // Set initial dimensions on video element if track doesn't provide them
                if (!settings.width || !settings.height) {
                    console.log('ðŸ“ Setting default video dimensions');
                    remoteVideo.width = 640;
                    remoteVideo.height = 480;
                } else {
                    console.log('ðŸ“ Using track dimensions:', settings.width, 'x', settings.height);
                    remoteVideo.width = settings.width;
                    remoteVideo.height = settings.height;
                }
                
                // Set the stream
                remoteVideo.srcObject = stream;
                console.log('âœ… Stream assigned to video element');
                
                // Show play overlay
                playOverlay.style.display = 'flex';
                
                // Add click handlers for video play with logging
                const overlayButton = playOverlay.querySelector('button');
                let playbackMonitor = null;
                
                // Function to handle video playback
                const startPlayback = async () => {
                    console.log('ðŸ‘† Start playback requested');
                    
                    // Double check stream state
                    if (!checkVideoState()) {
                        console.log('âš ï¸ Stream not ready yet, waiting 500ms...');
                        await new Promise(resolve => setTimeout(resolve, 500));
                        if (!checkVideoState()) {
                            console.error('âŒ Stream still not ready after waiting');
                            return;
                        }
                    }

                    try {
                        console.log('â–¶ï¸ Attempting video playback...');
                        await remoteVideo.play();
                        
                        console.log('âœ… Playback started! State:', {
                            playing: !remoteVideo.paused,
                            time: remoteVideo.currentTime,
                            dimensions: `${remoteVideo.videoWidth}x${remoteVideo.videoHeight}`
                        });
                        
                        playOverlay.style.display = 'none';
                        
                        // Monitor playback
                        const monitor = setInterval(() => {
                            const state = checkVideoState();
                            if (!state || remoteVideo.paused) {
                                console.log('âš ï¸ Playback interrupted, attempting resume...');
                                remoteVideo.play().catch(console.error);
                            }
                        }, 1000);
                        
                        // Cleanup monitor on end
                        remoteVideo.onended = () => clearInterval(monitor);
                        
                    } catch (err) {
                        console.error('âŒ Playback failed:', err);
                        // Show play overlay again
                        playOverlay.style.display = 'flex';
                        
                        if (err.name === 'NotAllowedError') {
                            console.log('ðŸ¤š Playback requires user interaction');
                        } else {
                            // Try to recover automatically
                            setTimeout(startPlayback, 1000);
                        }
                    }
                };
                
                overlayButton.onclick = (e) => {
                    e.stopPropagation();
                    console.log('ðŸŽ¯ Play button clicked');
                    startPlayback();
                };
                
                playOverlay.onclick = () => {
                    console.log('ðŸŽ¯ Play overlay clicked');
                    startPlayback();
                };
                
                remoteVideo.onclick = () => {
                    console.log('ðŸŽ¯ Video element clicked');
                    startPlayback();
                };
                
                // Handle metadata loading
                // Handle video events
                const events = ['loadedmetadata', 'loadeddata', 'canplay', 'playing', 'pause', 'ended'];
                events.forEach(event => {
                    remoteVideo.addEventListener(event, () => {
                        console.log(`ðŸŽ¥ Video event: ${event}`, {
                            dimensions: `${remoteVideo.videoWidth}x${remoteVideo.videoHeight}`,
                            readyState: remoteVideo.readyState,
                            paused: remoteVideo.paused,
                            time: remoteVideo.currentTime
                        });
                    });
                });
                
                remoteVideo.addEventListener('loadedmetadata', function metadataHandler() {
                    console.log('ðŸŽ¯ Metadata loaded! Dimensions:', {
                        videoWidth: remoteVideo.videoWidth,
                        videoHeight: remoteVideo.videoHeight,
                        naturalWidth: remoteVideo.naturalWidth,
                        naturalHeight: remoteVideo.naturalHeight
                    });
                    
                    if (remoteVideo.videoWidth > 0 && remoteVideo.videoHeight > 0) {
                        console.log('âœ… Video has valid dimensions!');
                        remoteVideo.removeEventListener('loadedmetadata', metadataHandler);
                        
                        // Update canvas size for detection overlay
                        const canvas = document.getElementById('detectionCanvas');
                        canvas.width = remoteVideo.videoWidth;
                        canvas.height = remoteVideo.videoHeight;
                        
                        // Show play overlay once we're sure we have valid video
                        playOverlay.style.display = 'flex';
                        
                        // Start a monitoring interval
                        setInterval(() => {
                            const state = checkVideoState();
                            if (state && !remoteVideo.paused) {
                                playOverlay.style.display = 'none';
                            }
                        }, 1000);
                    }
                });
                
                // Update video container visibility
                const videoContainer = document.querySelector('.video-container');
                videoContainer.style.display = 'flex';
                videoContainer.style.visibility = 'visible';
                remoteVideo.style.display = 'block';
            }
        } catch (error) {
            console.error('âŒ Error setting up video:', error);
            statusEl.textContent = 'Video setup failed. Please refresh the page.';
            statusEl.className = 'status disconnected';
        }
    }
        


    let peerConnection = null;
    let isConnecting = false;

    function cleanupPeerConnection() {
      if (peerConnection) {
        try {
          // Remove all tracks
          const senders = peerConnection.getSenders();
          senders.forEach(sender => {
            try {
              peerConnection.removeTrack(sender);
            } catch (e) {
              console.warn('Error removing track:', e);
            }
          });
          
          // Remove all event listeners
          peerConnection.ontrack = null;
          peerConnection.onicecandidate = null;
          peerConnection.oniceconnectionstatechange = null;
          
          // Store stream state for potential recovery
          const hadStream = remoteVideo && remoteVideo.srcObject !== null;
          
          // Close and remove all media streams
          if (remoteVideo && remoteVideo.srcObject) {
            remoteVideo.srcObject.getTracks().forEach(track => track.stop());
            remoteVideo.srcObject = null;
          }
          
          // Close the connection
          peerConnection.close();
          
          // Show reconnecting UI if we had a stream
          if (hadStream) {
            const streamStatus = document.getElementById('stream-status');
            if (streamStatus) {
              streamStatus.style.display = 'block';
              streamStatus.innerHTML = 'Reconnecting to camera stream...';
            }
            
            if (remoteVideo) {
              remoteVideo.style.display = 'none';
            }
            
            // Attempt to reconnect after a short delay
            setTimeout(() => {
              if (!peerConnection || peerConnection.iceConnectionState === 'closed') {
                console.log('Attempting to re-establish connection...');
                socket.emit('laptop-ready');
              }
            }, 2000);
          }
        } catch (e) {
          console.warn('Error during cleanup:', e);
        }
        peerConnection = null;
      }
      isConnecting = false;
    }

    function showPlayButton() {
        const playOverlay = document.getElementById('playOverlay');
        if (playOverlay) {
            playOverlay.style.display = 'flex';
        }
    }

    function hidePlayButton() {
        const playOverlay = document.getElementById('playOverlay');
        if (playOverlay) {
            playOverlay.style.display = 'none';
        }
    }

    function createPeerConnection() {
      // Prevent multiple active connections
      if (peerConnection && peerConnection.connectionState !== 'closed') {
          console.log('Closing existing peer connection before creating new one');
          cleanupPeerConnection();
      }
      
      if (isConnecting) {
          console.log('Connection already in progress, waiting...');
          return null;
      }
      
      try {
        console.log('Creating new peer connection...');
        isConnecting = true;

        peerConnection = new RTCPeerConnection({
          iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' },
            { urls: 'stun:stun2.l.google.com:19302' }
          ]
        });

        // Set up event handlers
        peerConnection.ontrack = async (event) => {
            console.log('âœ… Track received:', event.track.kind, event.track.readyState);
            
            const remoteVideo = document.getElementById('remoteVideo');
            const streamStatus = document.getElementById('stream-status');
            const videoStats = document.getElementById('video-stats');
            const streamError = document.getElementById('stream-error');
            
            if (!remoteVideo || !streamStatus || !videoStats) {
                console.error('Required elements not found');
                return;
            }

            // Get the stream
            const [remoteStream] = event.streams;
            if (!remoteStream) {
                console.error('No stream in track event');
                if (streamError) {
                    streamError.textContent = 'Error: No video stream received';
                    streamError.style.display = 'block';
                }
                return;
            }

            console.log('âœ… Stream received:', remoteStream.id);
            
            // Only set stream if it's different
            if (remoteVideo.srcObject !== remoteStream) {
                try {
                    // Update UI
                    streamStatus.innerHTML = 'Connecting to camera stream...';
                    remoteVideo.style.display = 'none';
                    videoStats.style.display = 'none';
                    
                    // Configure video element
                    remoteVideo.playsInline = true;
                    remoteVideo.muted = true;
                    remoteVideo.autoplay = false; // We'll manage playback manually

                    // Clear any existing stream
                    if (remoteVideo.srcObject) {
                        remoteVideo.srcObject.getTracks().forEach(track => track.stop());
                    }
                    
                    // Set new stream
                    remoteVideo.srcObject = remoteStream;
                    console.log('Stream attached to video element');

                    // Start managed playback
                    videoManager.startPlayback();
                    
                    // Wait for metadata and handle playback
                    remoteVideo.addEventListener('loadedmetadata', async () => {
                        console.log('âœ… Video metadata loaded:', remoteVideo.videoWidth, 'x', remoteVideo.videoHeight);
                        
                        // Update canvas for detection
                        const canvas = document.getElementById('detectionCanvas');
                        if (canvas) {
                            canvas.width = remoteVideo.videoWidth;
                            canvas.height = remoteVideo.videoHeight;
                            canvas.style.display = 'block';
                        }
                        
                        // Update video stats
                        videoStats.textContent = `${remoteVideo.videoWidth}x${remoteVideo.videoHeight}`;
                        
                        try {
                            // Make sure we're ready to play
                            if (remoteVideo.readyState < 2) { // HAVE_CURRENT_DATA
                                await new Promise((resolve) => {
                                    remoteVideo.addEventListener('loadeddata', resolve, { once: true });
                                });
                            }

                            // Clear any existing play promises
                            if (window.currentPlayPromise) {
                                try {
                                    await window.currentPlayPromise;
                                } catch (e) {
                                    console.warn('Previous play promise rejected:', e);
                                }
                            }

                            // Start playback
                            window.currentPlayPromise = remoteVideo.play();
                            await window.currentPlayPromise;
                            window.currentPlayPromise = null;

                            console.log('âœ… Video playing successfully');
                            
                            // Show video, hide status
                            remoteVideo.style.display = 'block';
                            streamStatus.style.display = 'none';
                            videoStats.style.display = 'block';
                            
                            // Setup stable playback monitoring
                            let isRetrying = false;
                            const playbackMonitor = setInterval(async () => {
                                if (!isRetrying && (remoteVideo.paused || remoteVideo.ended)) {
                                    console.log('âš ï¸ Video playback interrupted, attempting to resume...');
                                    isRetrying = true;
                                    try {
                                        await remoteVideo.play();
                                        console.log('âœ… Playback resumed successfully');
                                    } catch (e) {
                                        console.error('Failed to resume playback:', e);
                                        if (e.name === 'NotAllowedError') {
                                            addPlayButton(remoteVideo, streamStatus);
                                        }
                                    } finally {
                                        isRetrying = false;
                                    }
                                }
                            }, 1000);

                            // Cleanup monitor when video ends
                            remoteVideo.addEventListener('ended', () => clearInterval(playbackMonitor));
                            
                        } catch (error) {
                            console.log('âŒ Autoplay failed:', error);
                            addPlayButton(remoteVideo, streamStatus);
                        }
                    }, { once: true });
                    
                    // Monitor video state
                    setInterval(() => {
                        if (remoteVideo.srcObject && remoteVideo.srcObject.active) {
                            const track = remoteVideo.srcObject.getVideoTracks()[0];
                            if (track) {
                                const settings = track.getSettings();
                                videoStats.textContent = 
                                    `${settings.width}x${settings.height}@${settings.frameRate}fps`;
                            }
                        }
                    }, 1000);
                } catch (error) {
                    console.error('âŒ Error setting up video:', error);
                    streamError.textContent = 'Error: Failed to setup video stream';
                    streamError.style.display = 'block';
                }
            }
        };

        peerConnection.onicecandidate = (event) => {
          if (event.candidate) {
            console.log('Sending ICE candidate');
            socket.emit('ice-candidate', event.candidate);
          }
        };

        peerConnection.oniceconnectionstatechange = () => {
          const state = peerConnection.iceConnectionState;
          console.log("ICE Connection State:", state);
          
          if (state === 'disconnected') {
            console.log('Connection interrupted, waiting for recovery...');
            // Wait for potential recovery
            setTimeout(() => {
              if (peerConnection.iceConnectionState === 'disconnected') {
                console.log('Connection still interrupted, requesting reconnect...');
                socket.emit('laptop-ready'); // Request reconnection
              }
            }, 5000); // Wait 5 seconds before trying to reconnect
          } else if (state === 'failed' || state === 'closed') {
            console.log('Connection failed, cleaning up...');
            cleanupPeerConnection();
            // Request reconnection
            socket.emit('laptop-ready');
          } else if (state === 'connected' || state === 'completed') {
            console.log('Connection established successfully');
          }
        };

        console.log('Peer connection created successfully');
        return peerConnection;
      } catch (error) {
        console.error('Error creating peer connection:', error);
        cleanupPeerConnection();
        return null;
      }
    }

    function initUrl() {
      phoneUrlEl.textContent = `${window.location.origin}/phone`;
    }
    function copyUrl() {
      navigator.clipboard.writeText(phoneUrlEl.textContent).then(() => {
        alert('URL copied! Paste it in your phone browser.');
      });
    }

    // Helper function to check video state
    function checkVideoState() {
        const remoteVideo = document.getElementById('remoteVideo');
        const streamStatus = document.getElementById('streamStatus');
        const streamDetails = document.getElementById('streamDetails');
        const playOverlay = document.getElementById('playOverlay');
        
        if (!remoteVideo.srcObject) {
            console.log('âŒ No stream assigned to video');
            streamStatus.textContent = 'no stream';
            streamStatus.style.color = '#ff4444';
            streamDetails.textContent = 'Waiting for stream connection...';
            playOverlay.style.display = 'none'; // Hide play overlay until we have a stream
            
            // Request reconnection if no stream
            if (peerConnection && peerConnection.iceConnectionState === 'connected') {
                console.log('Connected but no stream, requesting reconnect...');
                socket.emit('laptop-ready');
            }
            return false;
        }

        const videoTrack = remoteVideo.srcObject.getVideoTracks()[0];
        if (!videoTrack) {
            console.log('âŒ No video track in stream');
            streamStatus.textContent = 'no video track';
            streamStatus.style.color = '#ff4444';
            streamDetails.textContent = 'No video track available';
            return false;
        }

        const state = {
            track: {
                enabled: videoTrack.enabled,
                state: videoTrack.readyState,
                settings: videoTrack.getSettings()
            },
            video: {
                paused: remoteVideo.paused,
                ready: remoteVideo.readyState,
                size: `${remoteVideo.videoWidth}x${remoteVideo.videoHeight}`,
                time: remoteVideo.currentTime
            }
        };

        console.log('ðŸ“Š Video state:', state);
        
        if (!videoTrack.enabled) {
            streamStatus.textContent = 'disabled';
            streamStatus.style.color = '#ff4444';
            streamDetails.textContent = 'Video track is disabled';
            return false;
        }
        
        if (videoTrack.readyState !== 'live') {
            streamStatus.textContent = videoTrack.readyState;
            streamStatus.style.color = '#ff9800';
            streamDetails.textContent = 'Video track is not live';
            return false;
        }
        
        if (remoteVideo.videoWidth === 0 || remoteVideo.videoHeight === 0) {
            streamStatus.textContent = 'no dimensions';
            streamStatus.style.color = '#ff9800';
            streamDetails.textContent = 'Waiting for video dimensions...';
            return false;
        }
        
        const settings = videoTrack.getSettings();
        streamStatus.textContent = 'ready';
        streamStatus.style.color = '#4CAF50';
        streamDetails.textContent = `${settings.width}x${settings.height} @ ${settings.frameRate}fps`;
        return true;
    }

    // Socket event handlers
    socket.on('phone-connected', async () => {
      console.log('Phone connected event received');
      try {
        // Update UI
        statusEl.textContent = 'Phone connected! ðŸŽ‰';
        statusEl.className = 'status connected';
        document.querySelector('.qr-section').style.display = 'none';
        document.querySelector('.header p').style.display = 'none';
        document.querySelector('.video-container').style.display = 'flex';

        // Clear any existing video state
        const remoteVideo = document.getElementById('remoteVideo');
        if (remoteVideo) {
            if (remoteVideo.srcObject) {
                remoteVideo.srcObject.getTracks().forEach(track => track.stop());
                remoteVideo.srcObject = null;
            }
            remoteVideo.load(); // Reset video element state
        }

        // Create new peer connection
        cleanupPeerConnection();
        const pc = createPeerConnection();
        if (!pc) {
          throw new Error("Failed to create peer connection");
        }

        // Signal readiness to the server
        console.log('Sending laptop-ready signal');
        socket.emit('laptop-ready');
      } catch (error) {
        console.error("Error in phone-connected handler:", error);
        statusEl.textContent = 'Connection failed. Please refresh and try again.';
        statusEl.className = 'status disconnected';
        cleanupPeerConnection();
      }
      try {
        // Update UI
        statusEl.textContent = 'Phone connected! ðŸŽ‰';
        statusEl.className = 'status connected';
        document.querySelector('.qr-section').style.display = 'none';
        document.querySelector('.header p').style.display = 'none';
        document.querySelector('.video-container').style.display = 'flex';

        // Create new peer connection
        if (!peerConnection && !isConnecting) {
          const pc = createPeerConnection();
          if (!pc) {
            throw new Error("Failed to create peer connection");
          }
        }

        // Signal readiness to the server
        console.log('Sending laptop-ready signal');
        if (!isConnecting && (!peerConnection || peerConnection.iceConnectionState !== 'connected')) {
          console.log('Sending laptop-ready signal');
          socket.emit('laptop-ready');
        }
      } catch (e) {
        console.error("Error in phone-connected handler:", e);
        statusEl.textContent = 'Connection failed. Please refresh and try again.';
        statusEl.className = 'status disconnected';
        cleanupPeerConnection();
      }
    });

    socket.on('offer', async (offer) => {
      console.log("Received offer from phone");
      try {
        // Clean up any existing connection first
        cleanupPeerConnection();
        
        // Create new peer connection
        console.log("Creating new peer connection for offer");
        const pc = createPeerConnection();
        if (!pc) {
          throw new Error("Failed to create peer connection for offer");
        }
        
        // Set remote description
        console.log("Setting remote description");
        await pc.setRemoteDescription(new RTCSessionDescription(offer));
        
        // Create and set local description
        console.log("Creating answer");
        const answer = await pc.createAnswer();
        console.log("Setting local description");
        await pc.setLocalDescription(answer);
        
        // Send answer
        console.log("Sending answer to phone");
        socket.emit('answer', answer);
        
        // Update UI
        statusEl.textContent = 'Connected to phone! ðŸŽ‰';
        statusEl.className = 'status connected';
      } catch (e) {
        console.error("Error handling offer:", e);
        statusEl.textContent = 'Connection failed. Please try again.';
        statusEl.className = 'status disconnected';
        cleanupPeerConnection();
      }
    });

    socket.on('ice-candidate', async (candidate) => {
      try {
        if (!peerConnection) {
          console.log("Waiting for peer connection...");
          return;
        }
        if (peerConnection.remoteDescription) {
          await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
          console.log("Added ICE candidate");
        } else {
          console.log("Waiting for remote description before adding ICE candidate");
        }
      } catch (e) {
        console.error("Error adding ICE candidate:", e);
      }
    });

    // Function to handle ICE connection recovery
    async function handleIceRecovery() {
        if (!peerConnection) return;
        
        console.log('Attempting ICE connection recovery...');
        try {
            await peerConnection.restartIce();
            console.log('ICE restart initiated');
        } catch (e) {
            console.error('ICE restart failed:', e);
            // If restart fails, request complete reconnection
            setTimeout(() => socket.emit('laptop-ready'), 2000);
        }
    }

    socket.on('phone-disconnected', () => {
      console.log('Phone disconnected, cleaning up...');
      
      // Clean up WebRTC
      cleanupPeerConnection();
      
      // Clean up video
      videoManager.stop();
      remoteVideo.style.display = 'none';
      
      // Update UI
      statusEl.textContent = 'Phone disconnected';
      statusEl.className = 'status disconnected';
      document.querySelector('.qr-section').style.display = 'block';
      document.querySelector('.header p').style.display = 'block';
      document.querySelector('.video-container').style.display = 'none';
      
      // Reset state
      isConnecting = false;
      
      console.log('Cleanup complete, ready for new connection');
    });

    socket.on('detection-results', (results) => {
      if (!canvas || !ctx) {
        console.warn('Canvas not initialized yet');
        return;
      }

      if (!canvas.width || !canvas.height) {
        canvas.width = remoteVideo.videoWidth || 640;
        canvas.height = remoteVideo.videoHeight || 480;
      }
      
      try {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (results.detections && Array.isArray(results.detections)) {
          results.detections.forEach(detection => {
            const x = detection.xmin * canvas.width;
            const y = detection.ymin * canvas.height;
            const width = (detection.xmax - detection.xmin) * canvas.width;
            const height = (detection.ymax - detection.ymin) * canvas.height;
            
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, width, height);
            
            const label = `${detection.label} (${Math.round(detection.score * 100)}%)`;
            ctx.font = '16px Arial';
            ctx.fillStyle = 'black';
            ctx.fillRect(x, y - 20, ctx.measureText(label).width + 10, 20);
            ctx.fillStyle = '#00ff00';
            ctx.fillText(label, x + 5, y - 5);
          });
        }
        
        if (statsEl) {
          statsEl.textContent = `Detections: ${results.detections ? results.detections.length : 0}\nInference time: ${results.inference_time}ms`;
        }
      } catch (error) {
        console.error('Error drawing detections:', error);
      }
    });

    initUrl();
    console.log('Laptop view initialized');
  </script>
</body>
</html>
